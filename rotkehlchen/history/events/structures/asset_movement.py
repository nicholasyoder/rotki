import logging
from typing import TYPE_CHECKING, Any, Literal, NotRequired, TypedDict

from rotkehlchen.accounting.mixins.event import AccountingEventType
from rotkehlchen.assets.asset import Asset
from rotkehlchen.constants import ZERO
from rotkehlchen.constants.location_details import get_formatted_location_name
from rotkehlchen.errors.serialization import DeserializationError
from rotkehlchen.fval import FVal
from rotkehlchen.history.events.structures.base import (
    HISTORY_EVENT_DB_TUPLE_WRITE,
    HistoryBaseEntry,
    HistoryBaseEntryType,
)
from rotkehlchen.history.events.structures.types import (
    HistoryEventSubType,
    HistoryEventType,
)
from rotkehlchen.history.events.utils import create_group_identifier
from rotkehlchen.logging import RotkehlchenLogsAdapter
from rotkehlchen.serialization.deserialize import deserialize_fval
from rotkehlchen.types import AssetAmount, Location, TimestampMS
from rotkehlchen.utils.misc import ts_ms_to_sec

if TYPE_CHECKING:
    from more_itertools import peekable

    from rotkehlchen.accounting.mixins.event import AccountingEventMixin
    from rotkehlchen.accounting.pot import AccountingPot

logger = logging.getLogger(__name__)
log = RotkehlchenLogsAdapter(logger)


class AssetMovementExtraData(TypedDict):
    """Typed dict with all the valid fields used in extra_data for AssetMovements"""
    # Address receiving or sending funds in the asset movement.
    address: NotRequired[str]
    # Transaction if it is available where funds were moved on chain.
    transaction_id: NotRequired[str]
    # Internal reference used in exchanges.
    reference: NotRequired[str]
    # Internal use only. Used for matching the corresponding crypto_transaction. Removed before being saved to the DB.  # noqa: E501
    fee: NotRequired['FVal']
    # Blockchain that the funds are moving from/to. Simply a string since it could be unsupported.
    # Note that if it is a supported chain, it should be a serialized SupportedBlockchain value
    # so we can properly read the value during asset movement matching.
    blockchain: NotRequired[str]
    # Used when an asset movement is matched with another asset movement in exchange to exchange transfers.  # noqa: E501
    matched_asset_movement: NotRequired[dict[str, Any]]


AssetMovementSubtype = Literal[
    HistoryEventSubType.RECEIVE,
    HistoryEventSubType.SPEND,
    HistoryEventSubType.FEE,
]
AssetMovementTransferSubtype = Literal[HistoryEventSubType.RECEIVE, HistoryEventSubType.SPEND]


class AssetMovement(HistoryBaseEntry[AssetMovementExtraData | None]):
    """Asset movement event representing deposits and withdrawals on exchanges."""

    extra_data: AssetMovementExtraData | None

    def __init__(
            self,
            timestamp: TimestampMS,
            location: Location,
            event_subtype: Literal[
                HistoryEventSubType.RECEIVE,
                HistoryEventSubType.SPEND,
                HistoryEventSubType.FEE,
            ],
            asset: Asset,
            amount: FVal,
            identifier: int | None = None,
            group_identifier: str | None = None,
            unique_id: str | None = None,
            extra_data: AssetMovementExtraData | None = None,
            location_label: str | None = None,
            notes: str | None = None,
    ) -> None:
        """
        An asset movement (deposit/withdrawal) event. Important to note that the amount of
        the deposit/withdrawal is after the fee. So if you withdraw 1000 USDC and pay 1 USDC fee
        and the final amount that hits your address is 999. Then the amount should be 999
        and the fee should be 1

        `unique_id`: Unique identifier for this asset movement.
            Either the exchange transaction id or the associated onchain transaction hash.
            Used in conjunction with location to generate the group identifier.
        `notes`: Notes specified by the user. Appended to the autogenerated notes.

        May raise UnknownAsset.
        """
        sequence_index = 1 if event_subtype == HistoryEventSubType.FEE else 0

        super().__init__(
            group_identifier=group_identifier if group_identifier is not None else create_group_identifier(  # noqa: E501
                location=location,
                timestamp=timestamp,
                asset=asset,
                amount=amount,
                unique_id=unique_id,
            ),
            sequence_index=sequence_index,
            timestamp=timestamp,
            location=location,
            event_type=HistoryEventType.EXCHANGE_TRANSFER,
            event_subtype=event_subtype,
            asset=asset,
            amount=amount,
            notes=notes,
            identifier=identifier,
            extra_data=extra_data,
            location_label=location_label,
        )

    @property
    def entry_type(self) -> HistoryBaseEntryType:
        return HistoryBaseEntryType.ASSET_MOVEMENT_EVENT

    def serialize_for_db(self) -> tuple[tuple[str, str, HISTORY_EVENT_DB_TUPLE_WRITE]]:
        return (self._serialize_base_tuple_for_db(),)

    @classmethod
    def deserialize_from_db(cls: type['AssetMovement'], entry: tuple) -> 'AssetMovement':
        """Deserialize an AssetMovement DB tuple.
        May raise:
        - DeserializationError
        - UnknownAsset
        But these exceptions shouldn't normally happen since
        the data from the db should already be correct.
        """
        amount = deserialize_fval(entry[7], 'amount', 'asset movement event')
        event_type = HistoryEventType.deserialize(entry[9])  # should always be correct from the DB
        if event_type != HistoryEventType.EXCHANGE_TRANSFER:
            raise DeserializationError(
                f'Unsupported asset movement event type {event_type}. '
                f'Expected EXCHANGE_TRANSFER',
            )
        event_subtype = HistoryEventSubType.deserialize(entry[10])
        if event_subtype not in (
            HistoryEventSubType.FEE,
            HistoryEventSubType.RECEIVE,
            HistoryEventSubType.SPEND,
        ):
            raise DeserializationError(
                f'Unsupported asset movement event subtype {event_subtype}. '
                f'Expected RECEIVE, SPEND or FEE',
            )

        return cls(
            identifier=entry[0],
            group_identifier=entry[1],
            timestamp=TimestampMS(entry[3]),
            location=Location.deserialize_from_db(entry[4]),
            location_label=entry[5],
            event_subtype=event_subtype,  # type: ignore[arg-type]  # guarded by runtime subtype validation above; mypy does not narrow Literal aliases from membership tests
            asset=Asset(entry[6]).check_existence(),
            amount=amount,
            extra_data=cls.deserialize_extra_data(entry=entry, extra_data=entry[11]),
            notes=entry[8],
        )

    def serialize(self) -> dict[str, Any]:
        """Serialize the event for api, and generate the auto_notes.
        May raise UnknownAsset, but this would be an edge case as the asset should already have
        been checked for existence when it was deserialized from an API or from the database.
        """
        serialized_data = super().serialize()
        location_name = get_formatted_location_name(self.location)
        asset_symbol = self.asset.symbol_or_name()
        if self.event_subtype == HistoryEventSubType.FEE:
            auto_notes = f'Pay {self.amount} {asset_symbol} as {location_name} {str(self.event_type).lower()} fee'  # noqa: E501
        elif self.event_subtype == HistoryEventSubType.RECEIVE:
            auto_notes = f'Deposit {self.amount} {asset_symbol} to {location_name}'
        else:  # spend
            auto_notes = f'Withdraw {self.amount} {asset_symbol} from {location_name}'

        serialized_data['auto_notes'] = auto_notes
        return serialized_data

    @classmethod
    def deserialize(cls: type['AssetMovement'], data: dict[str, Any]) -> 'AssetMovement':
        base_data = cls._deserialize_base_history_data(data)
        event_subtype = base_data['event_subtype']
        if event_subtype not in (
            HistoryEventSubType.FEE,
            HistoryEventSubType.RECEIVE,
            HistoryEventSubType.SPEND,
        ):
            raise DeserializationError(
                f'Unsupported asset movement event subtype {event_subtype}. '
                f'Expected RECEIVE, SPEND or FEE',
            )

        return cls(
            identifier=base_data['identifier'],
            group_identifier=base_data['group_identifier'],
            timestamp=base_data['timestamp'],
            location=base_data['location'],
            location_label=base_data['location_label'],
            event_subtype=event_subtype,  # type: ignore[arg-type]  # guarded by runtime subtype validation above; mypy does not narrow Literal aliases from membership tests
            asset=base_data['asset'],
            amount=base_data['amount'],
            extra_data=base_data['extra_data'],
            notes=base_data['notes'],
        )

    def __repr__(self) -> str:
        return f'AssetMovement({", ".join(self._history_base_entry_repr_fields())})'

    # -- Methods of AccountingEventMixin

    @staticmethod
    def get_accounting_event_type() -> AccountingEventType:
        return AccountingEventType.ASSET_MOVEMENT

    def process(
            self,
            accounting: 'AccountingPot',
            events_iterator: "peekable['AccountingEventMixin']",  # pylint: disable=unused-argument
    ) -> int:
        if self.asset.identifier == 'KFEE' or self.amount == ZERO:
            # There is no reason to process deposits of KFEE for kraken as it has only value
            # internal to kraken and KFEE has no value and will error at cryptocompare price query.
            return 1

        if self.event_subtype == HistoryEventSubType.FEE:
            event_settings, _ = accounting.events_accountant.rules_manager.get_event_settings(self)
            if event_settings is None:
                taxable = count_entire_amount_spend = count_cost_basis_pnl = True
            else:
                taxable = event_settings.taxable
                count_entire_amount_spend = event_settings.count_entire_amount_spend
                count_cost_basis_pnl = event_settings.count_cost_basis_pnl

            accounting.add_out_event(
                originating_event_id=self.identifier,
                event_type=AccountingEventType.ASSET_MOVEMENT,
                notes=self.notes if self.notes is not None else '',
                location=self.location,
                timestamp=ts_ms_to_sec(self.timestamp),
                asset=self.asset,
                amount=self.amount,
                taxable=taxable,
                count_entire_amount_spend=count_entire_amount_spend,
                count_cost_basis_pnl=count_cost_basis_pnl,
            )

        return 1


def create_asset_movement_with_fee(
        timestamp: TimestampMS,
        location: Location,
        event_subtype: AssetMovementTransferSubtype,
        asset: Asset,
        amount: 'FVal',
        fee: AssetAmount | None = None,
        location_label: str | None = None,
        unique_id: str | None = None,
        identifier: int | None = None,
        fee_identifier: int | None = None,
        group_identifier: str | None = None,
        extra_data: AssetMovementExtraData | None = None,
        movement_notes: str | None = None,
        fee_notes: str | None = None,
) -> list[AssetMovement]:
    """Create an asset movement and its corresponding fee event.
    Returns the new asset movements in a list.
    """
    events = [AssetMovement(
        location=location,
        event_subtype=event_subtype,
        timestamp=timestamp,
        asset=asset,
        amount=amount,
        unique_id=unique_id,
        identifier=identifier,
        group_identifier=group_identifier,
        extra_data=extra_data,
        location_label=location_label,
        notes=movement_notes,
    )]
    if fee is not None and fee.amount != ZERO:
        events.append(AssetMovement(
            identifier=fee_identifier,
            group_identifier=events[0].group_identifier,
            location=location,
            timestamp=timestamp,
            asset=fee.asset,
            amount=fee.amount,
            event_subtype=HistoryEventSubType.FEE,
            location_label=location_label,
            notes=fee_notes,
        ))

    return events
